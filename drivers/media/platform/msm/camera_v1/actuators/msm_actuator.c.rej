--- drivers/media/platform/msm/camera_v1/actuators/msm_actuator.c
+++ drivers/media/platform/msm/camera_v1/actuators/msm_actuator.c
@@ -13,25 +13,6 @@
 #include <linux/module.h>
 #include "msm_actuator.h"
 
-
-#ifdef CONFIG_SEKONIX_LENS_ACT
-#define CHECK_ACT_WRITE_COUNT
-#define ACT_STOP_POS            10
-#define ACT_MIN_MOVE_RANGE      200
-#define ACT_POSTURE_MARGIN      100
-extern uint8_t imx111_afcalib_data[4];
-#else
-/* modification qct's af calibration routines */
-#define ACTUATOR_EEPROM_SADDR                (0x50 >> 1)
-#define ACTUATOR_START_ADDR                  0x06
-#define ACTUATOR_MACRO_ADDR                  0x08
-#define ACTUATOR_MARGIN                      30
-#define ACTUATOR_MIN_MOVE_RANGE              200 // TBD
-#endif
-
-struct region_params_t tmp_region_params[MAX_ACTUATOR_REGION];
-unsigned char frun = 0;
-
 static struct msm_actuator_ctrl_t msm_actuator_t;
 static struct msm_actuator msm_vcm_actuator_table;
 static struct msm_actuator msm_piezo_actuator_table;
@@ -66,6 +47,7 @@
 	}
 	return rc;
 }
+int use_eeprom_make_table;
 
 static int32_t msm_actuator_parse_i2c_params(struct msm_actuator_ctrl_t *a_ctrl,
 	int16_t next_lens_position, uint32_t hw_params, uint16_t delay)
@@ -78,13 +60,17 @@
 	int32_t rc = 0;
 	struct msm_camera_i2c_reg_tbl *i2c_tbl = a_ctrl->i2c_reg_tbl;
 	CDBG("%s: IN\n", __func__);
-	
-	uint8_t hw_reg_write = 1;
-        if (a_ctrl->curr_hwparams == hw_params)
-                hw_reg_write = 0;
-	
 	for (i = 0; i < size; i++) {
+
+		/*                                                                                                                                           */
+		if(a_ctrl->i2c_tbl_index > ((a_ctrl->total_steps*2)+1)) {
+			pr_err("[ERR] %s, i2c_tbl_index is large than alloced size of i2c_tbl_index", __func__);
+			break;
+		}
+		/*                                                                                                                                           */
+
 		if (write_arr[i].reg_write_type == MSM_ACTUATOR_WRITE_DAC) {
+		    // Flow Here
 			value = (next_lens_position <<
 				write_arr[i].data_shift) |
 				((hw_dword & write_arr[i].hw_mask) >>
@@ -109,28 +95,23 @@
 					i2c_byte2 = (value & 0xFF00) >> 8;
 				}
 			} else {
+			    // Flow Here
 				i2c_byte1 = (value & 0xFF00) >> 8;
 				i2c_byte2 = value & 0xFF;
 			}
-			i2c_tbl[a_ctrl->i2c_tbl_index].reg_addr = i2c_byte1;
-			i2c_tbl[a_ctrl->i2c_tbl_index].reg_data = i2c_byte2;
-			i2c_tbl[a_ctrl->i2c_tbl_index].delay = delay;
-			a_ctrl->i2c_tbl_index++;
 		} else {
-			if (hw_reg_write) {
-				i2c_byte1 = write_arr[i].reg_addr;
-				i2c_byte2 = (hw_dword & write_arr[i].hw_mask) >>
-					write_arr[i].hw_shift;
-				i2c_tbl[a_ctrl->i2c_tbl_index].reg_addr = i2c_byte1;
-				i2c_tbl[a_ctrl->i2c_tbl_index].reg_data = i2c_byte2;
-				i2c_tbl[a_ctrl->i2c_tbl_index].delay = delay;
-				a_ctrl->i2c_tbl_index++;
-			}
+			i2c_byte1 = write_arr[i].reg_addr;
+			i2c_byte2 = (hw_dword & write_arr[i].hw_mask) >>
+				write_arr[i].hw_shift;
 		}
+		CDBG("%s: i2c_byte1:0x%x, i2c_byte2:0x%x\n", __func__,
+			i2c_byte1, i2c_byte2);
+		i2c_tbl[a_ctrl->i2c_tbl_index].reg_addr = i2c_byte1;
+		i2c_tbl[a_ctrl->i2c_tbl_index].reg_data = i2c_byte2;
+		i2c_tbl[a_ctrl->i2c_tbl_index].delay = delay;
+		a_ctrl->i2c_tbl_index++;
 	}
 		CDBG("%s: OUT\n", __func__);
-	if (rc == 0)
-		a_ctrl->curr_hwparams = hw_params;
 	return rc;
 }
 
@@ -181,48 +162,87 @@
 	int16_t next_lens_pos = 0;
 	uint16_t damping_code_step = 0;
 	uint16_t wait_time = 0;
+/*                                                                 */
+#ifndef CONFIG_MACH_APQ8064_AWIFI //                                                                            
+    uint16_t AF_offset_direction=0;
+	uint16_t AF_offset = 0;
+#endif
+/*                                                                 */
 
 	damping_code_step = damping_params->damping_step;
 	wait_time = damping_params->damping_delay;
 
-#ifdef CONFIG_SEKONIX_LENS_ACT
-	CDBG("damping_code_step = %d\n",damping_code_step);
-	CDBG("wait_time = %d\n",wait_time);
-	CDBG("curr_lens_pos = %d\n",curr_lens_pos);
-	CDBG("sign_direction = %d\n",sign_direction);
-	CDBG("code_boundary = %d\n",code_boundary);
-	CDBG("damping_params->hw_params = %d\n",damping_params->hw_params);
-
-	if (damping_code_step ==0) {
-		CDBG("[ERROR][%s] damping_code_step = %d ---> 255\n",
-				__func__,damping_code_step);
+//	pr_err("%s: sign_direction :%d damping_params->damping_step:%d\n", __func__, sign_direction, damping_params->damping_step);
+       //                                                                                          
+
+	if (damping_code_step ==0)
+	{
+		CDBG("[ERROR][%s] damping_code_step = %d ---> 255\n",__func__,damping_code_step);
 		damping_code_step = 255;
 	}
-	if (wait_time ==0) {
-		CDBG("[ERROR][%s] wait_time = %d ---> 4500\n",
-				__func__,damping_code_step);
+	if (wait_time ==0)
+	{
+		CDBG("[ERROR][%s] wait_time = %d ---> 4500\n",__func__,damping_code_step);
 		wait_time = 4500;
 	}
-#endif
+	//                                                                                           
 	/* Write code based on damping_code_step in a loop */
-	for (next_lens_pos =
-		curr_lens_pos + (sign_direction * damping_code_step);
-		(sign_direction * next_lens_pos) <=
-			(sign_direction * code_boundary);
-		next_lens_pos =
-			(next_lens_pos +
-				(sign_direction * damping_code_step))) {
-		rc = a_ctrl->func_tbl->
-			actuator_parse_i2c_params(a_ctrl, next_lens_pos,
-				damping_params->hw_params, wait_time);
-		if (rc < 0) {
-			pr_err("%s: error:%d\n",
-				__func__, rc);
-			return rc;
+#ifndef CONFIG_MACH_APQ8064_AWIFI //                                                                            
+	if (!use_eeprom_make_table)
+#else  // CONFIG_MACH_APQ8064_AWIFI
+	if (1)
+#endif
+	{
+		for (next_lens_pos =
+			curr_lens_pos + (sign_direction * damping_code_step);
+			(sign_direction * next_lens_pos) <=
+				(sign_direction * code_boundary);
+			next_lens_pos =
+				(next_lens_pos +
+					(sign_direction * damping_code_step))) {
+			rc = a_ctrl->func_tbl->
+				actuator_parse_i2c_params(a_ctrl, next_lens_pos,
+					damping_params->hw_params, wait_time);
+			if (rc < 0) {
+				pr_err("%s: error:%d\n",
+					__func__, rc);
+				return rc;
+			}
+			curr_lens_pos = next_lens_pos;
 		}
-		curr_lens_pos = next_lens_pos;
 	}
+//                                                                                          
+/*                                                                 */
+			//printk("#### code_boundary : %d, a_ctrl->af_status = %d ####\n", code_boundary, a_ctrl->af_status);
+#ifndef CONFIG_MACH_APQ8064_AWIFI //                                                                              
+			if((a_ctrl->af_status==6)  && (a_ctrl->AF_defocus_enable==1))  //af_status : 6 = Last AF
+			{
+				AF_offset_direction = 0x8000 & ( a_ctrl->AF_LG_defocus_offset);
+				AF_offset = 0x7FFF & ( a_ctrl->AF_LG_defocus_offset);
+
+				if (0x8000==AF_offset_direction)
+				{
+					AF_offset = ~(AF_offset |0x8000) + 1;
+
+					if (AF_offset > 30)
+						AF_offset =0;
+
+					code_boundary = code_boundary -AF_offset;
+				}
+				else
+				{
+					if (AF_offset > 30)
+						AF_offset =0;
+					code_boundary = code_boundary + AF_offset;
 
+				}
+
+//				printk("#### Last AF 1, code : %d, offset : %d !!! ####\n", code_boundary, a_ctrl->AF_LG_defocus_offset);
+			}
+			//printk("#### %s : code_boundary = %d, state = %d ####\n",__func__, code_boundary, a_ctrl->af_status);
+/*                                                                 */
+//                                                                                        
+#endif //                                                                              
 	if (curr_lens_pos != code_boundary) {
 		rc = a_ctrl->func_tbl->
 			actuator_parse_i2c_params(a_ctrl, code_boundary,
@@ -236,9 +256,17 @@
 	struct msm_actuator_move_params_t *move_params)
 {
 	int32_t dest_step_position = move_params->dest_step_pos;
+	struct damping_params_t ringing_params_kernel;
 	int32_t rc = 0;
 	int32_t num_steps = move_params->num_steps;
 
+	if (copy_from_user(&ringing_params_kernel,
+		&(move_params->ringing_params[0]),
+		sizeof(struct damping_params_t))) {
+			pr_err("copy_from_user failed\n");
+			return -EFAULT;
+	}
+
 	if (num_steps == 0)
 		return rc;
 
@@ -247,7 +275,7 @@
 		actuator_parse_i2c_params(a_ctrl,
 		(num_steps *
 		a_ctrl->region_params[0].code_per_step),
-		move_params->ringing_params[0].hw_params, 0);
+		ringing_params_kernel.hw_params, 0);
 
 	rc = msm_camera_i2c_write_table_w_microdelay(&a_ctrl->i2c_client,
 		a_ctrl->i2c_reg_tbl, a_ctrl->i2c_tbl_index,
@@ -273,59 +301,100 @@
 	uint16_t target_lens_pos = 0;
 	int16_t dest_step_pos = move_params->dest_step_pos;
 	uint16_t curr_lens_pos = 0;
+	uint16_t dest_lens_pos = 0;
 	int dir = move_params->dir;
-	struct damping_params_t damping_param;
-#ifdef CONFIG_MSM_CAMERA_DEBUG
 	int32_t num_steps = move_params->num_steps;
-#endif
-#ifdef CHECK_ACT_WRITE_COUNT
+	struct damping_params_t ringing_params_kernel;
+
+    //                                                                                             
 	int count_actuator_write = 0;
-	CDBG("%s: a_ctrl->curr_region_index = %d\n",
-			__func__,a_ctrl->curr_region_index);
-#endif
-	CDBG("%s called, dir %d, num_steps %d\n",__func__,dir,num_steps);
+	 //                                                                                          
 
-	if (!a_ctrl->step_position_table) {
-		pr_err("%s: Not yet configured (step_position_table is NULL)\n",
-				__func__);
-		return -EINVAL;
+	if (copy_from_user(&ringing_params_kernel,
+		&(move_params->ringing_params[a_ctrl->curr_region_index]),
+		sizeof(struct damping_params_t))) {
+			pr_err("copy_from_user failed\n");
+			return -EFAULT;
 	}
 
+	CDBG("%s called, dir %d, num_steps %d\n",
+		__func__,
+		dir,
+		num_steps);
+       /*                                                                 */
+	a_ctrl->af_status = move_params->af_status;
+/*                                                                 */
+
 	if (dest_step_pos == a_ctrl->curr_step_pos)
 		return rc;
-
+	if ((sign_dir > MSM_ACTUATOR_MOVE_SIGNED_NEAR) ||
+		(sign_dir < MSM_ACTUATOR_MOVE_SIGNED_FAR)) {
+		pr_err("%s:%d Invalid sign_dir = %d\n",
+		__func__, __LINE__, sign_dir);
+		return -EFAULT;
+	}
+	if ((dir > MOVE_FAR) || (dir < MOVE_NEAR)) {
+		pr_err("%s:%d Invalid direction = %d\n",
+		 __func__, __LINE__, dir);
+		return -EFAULT;
+	}
+	if (dest_step_pos > a_ctrl->total_steps) {
+		pr_err("Step pos greater than total steps = %d\n",
+		dest_step_pos);
+		return -EFAULT;
+	}
+	if (a_ctrl->curr_step_pos > a_ctrl->total_steps) {
+		pr_err("Step pos greater than total steps = %d\n",
+		a_ctrl->curr_step_pos);
+		return -EFAULT;
+	}
 	curr_lens_pos = a_ctrl->step_position_table[a_ctrl->curr_step_pos];
+	dest_lens_pos = a_ctrl->step_position_table[dest_step_pos];
 	a_ctrl->i2c_tbl_index = 0;
-	CDBG("curr_step_pos =%d dest_step_pos =%d curr_lens_pos=%d\n",
-		a_ctrl->curr_step_pos, dest_step_pos, curr_lens_pos);
+	//                                                                                          
+	pr_err("curr_step_pos =%d dest_step_pos =%d curr_lens_pos=%d dest_lens_pos = %d\n",
+		a_ctrl->curr_step_pos, dest_step_pos, curr_lens_pos, dest_lens_pos);
+	//                                                                                        
 
 	while (a_ctrl->curr_step_pos != dest_step_pos) {
 		step_boundary =
 			a_ctrl->region_params[a_ctrl->curr_region_index].
 			step_bound[dir];
-
-		if (copy_from_user(&damping_param,
-				   &(move_params->
-					   ringing_params[a_ctrl->
-					   curr_region_index]),
-				   sizeof(struct damping_params_t))) {
-			pr_err("%s: copy_from_user\n", __func__);
-			return -EFAULT;
-		}
-
 		if ((dest_step_pos * sign_dir) <=
 			(step_boundary * sign_dir)) {
 
+/*                                                                                               */
+			struct damping_params_t damping_param, *usr_damping_param ; // namkyu2.kang
+/*                                                                                               */
 			target_step_pos = dest_step_pos;
 			target_lens_pos =
 				a_ctrl->step_position_table[target_step_pos];
-			if (curr_lens_pos == target_lens_pos)
-				return rc;
+/*                                                                                               */
+			usr_damping_param = &(move_params->ringing_params[a_ctrl->curr_region_index]) ;
+			if (copy_from_user(&damping_param,
+					(void *)usr_damping_param,
+					sizeof(struct damping_params_t)))
+			{
+				pr_err("%s: ringing_param is on FAULT Address : %p\n",
+						__func__, (void *)usr_damping_param ) ;
+				return -EFAULT;
+			}
+/*                                                                                               */
 			rc = a_ctrl->func_tbl->
 				actuator_write_focus(
 					a_ctrl,
 					curr_lens_pos,
-					&damping_param,
+/*                                                                                               */
+//					&(move_params->
+//						ringing_params[a_ctrl->
+//						curr_region_index]),
+					&damping_param, // namkyu2.kang
+/*                                                                                               */
+/*
+NEED TO CHECK
+QCT ES0 patch
+					&ringing_params_kernel,
+*/
 					sign_dir,
 					target_lens_pos);
 			if (rc < 0) {
@@ -334,23 +403,46 @@
 				return rc;
 			}
 			curr_lens_pos = target_lens_pos;
-
-#ifdef CHECK_ACT_WRITE_COUNT
+			//                                                                                             
 			count_actuator_write ++;
-			CDBG("%s count_actuator_write = %d\n",__func__,count_actuator_write);
-#endif
+			//printk("%s count_actuator_write = %d\n",__func__,count_actuator_write);
+			//                                                                                           
 
 		} else {
+/*                                                                                               */
+			struct damping_params_t damping_param, *usr_damping_param ; // namkyu2.kang
+/*                                                                                               */
 			target_step_pos = step_boundary;
 			target_lens_pos =
 				a_ctrl->step_position_table[target_step_pos];
-			if (curr_lens_pos == target_lens_pos)
-				return rc;
+/*                                                                                               */
+			usr_damping_param = &(move_params->ringing_params[a_ctrl->curr_region_index]) ;
+			if (copy_from_user(&damping_param,
+					(void *)usr_damping_param,
+					sizeof(struct damping_params_t)))
+			{
+				pr_err("%s: ringing_param is on FAULT Address : %p\n",
+						__func__, (void *)usr_damping_param ) ;
+				return -EFAULT;
+			}
+/*                                                                                               */
+			//pr_err("%s:[2] usr_damping_param = %p", __func__, usr_damping_param);
+			//pr_err("%s:[2] &(move_params->ringing_params[a_ctrl->curr_region_index]) = %p\n",  __func__, &(move_params->ringing_params[a_ctrl->curr_region_index]));
 			rc = a_ctrl->func_tbl->
 				actuator_write_focus(
 					a_ctrl,
 					curr_lens_pos,
-					&damping_param,
+/*                                                                                               */
+//					&(move_params->
+//						ringing_params[a_ctrl->
+//						curr_region_index]),
+					&damping_param, // namkyu2.kang
+/*                                                                                               */
+/*
+NEED TO CHECK
+QCT ES0 patch
+					&ringing_params_kernel,
+*/
 					sign_dir,
 					target_lens_pos);
 			if (rc < 0) {
@@ -361,20 +453,29 @@
 			curr_lens_pos = target_lens_pos;
 
 			a_ctrl->curr_region_index += sign_dir;
-#ifdef CHECK_ACT_WRITE_COUNT
-			if (a_ctrl->curr_region_index >= 2) {
-				CDBG("[ERROR][%s] a_ctrl->curr_region_index = %d ---> 1\n",__func__,a_ctrl->curr_region_index);
-				a_ctrl->curr_region_index = 1;
+			//                                                                                             
+			if (a_ctrl->curr_region_index >= 2)
+			{
+			 printk("[ERROR][%s] a_ctrl->curr_region_index = %d ---> 1\n",__func__,a_ctrl->curr_region_index);
+			 a_ctrl->curr_region_index = 1;
 			}
-			if (a_ctrl->curr_region_index < 0) {
-				CDBG("[ERROR][%s] a_ctrl->curr_region_index = %d ---> 0\n",__func__,a_ctrl->curr_region_index);
-				a_ctrl->curr_region_index = 0;
+			if (a_ctrl->curr_region_index < 0)
+			{
+			 printk("[ERROR][%s] a_ctrl->curr_region_index = %d ---> 0\n",__func__,a_ctrl->curr_region_index);
+			 a_ctrl->curr_region_index = 0;
 			}
 			count_actuator_write ++;
-			CDBG("%s count_actuator_write = %d\n",__func__,count_actuator_write);
-#endif
+			//printk("%s count_actuator_write = %d\n",__func__,count_actuator_write);
+			//                                                                                           
 		}
 		a_ctrl->curr_step_pos = target_step_pos;
+		//                                                                                             
+		if (count_actuator_write > 2)
+		{
+		   printk("[ERROR][%s] count_actuator_write = %d ---> break\n",__func__,count_actuator_write);
+		   break;
+	    }
+		//                                                                                           
 	}
 
 	rc = msm_camera_i2c_write_table_w_microdelay(&a_ctrl->i2c_client,
@@ -390,77 +491,225 @@
 	return rc;
 }
 
-static int32_t msm_actuator_init_default_step_table(struct msm_actuator_ctrl_t *a_ctrl,
-	struct msm_actuator_set_info_t *set_info)
+/*                                                                                               */
+#if defined(CONFIG_MACH_APQ8064_AWIFI)
+static int32_t msm_actuator_move_focus_manual(
+	struct msm_actuator_ctrl_t *a_ctrl,
+	struct msm_actuator_move_params_t *move_params)
 {
-	int16_t code_per_step = 0;
 	int32_t rc = 0;
-	int16_t cur_code = 0;
-	int16_t step_index = 0, region_index = 0;
+	int8_t sign_dir = move_params->sign_dir;
 	uint16_t step_boundary = 0;
-	uint32_t max_code_size = 1;
-	uint16_t data_size = set_info->actuator_params.data_size;
-
-	CDBG("%s called\n", __func__);
-
-	if(!frun){
-	    memcpy(&tmp_region_params,&a_ctrl->region_params,sizeof(tmp_region_params));
-	    frun++;
-	}else{
-	    memcpy(&a_ctrl->region_params,&tmp_region_params,sizeof(tmp_region_params));
-	}
+	uint16_t target_step_pos = 0;
+	uint16_t target_lens_pos = 0;
+	int16_t dest_step_pos = move_params->dest_step_pos;
+	uint16_t curr_lens_pos = 0;
+	int dir = move_params->dir;
+	int32_t num_steps = move_params->num_steps;
 
-	for (; data_size > 0; data_size--)
-		max_code_size *= 2;
+    //                                                                                             
+	int count_actuator_write = 0;
+	 //                                                                                          
+	CDBG("%s called, dir %d, num_steps %d\n",
+		__func__,
+		dir,
+		num_steps);
+       /*                                                                 */
+	a_ctrl->af_status = move_params->af_status;
+/*                                                                 */
 
-	if (a_ctrl->step_position_table) {
-		kfree(a_ctrl->step_position_table);
-		a_ctrl->step_position_table = NULL;
-	}
+	if (dest_step_pos == a_ctrl->curr_step_pos)
+		return rc;
 
-	/* Fill step position table */
-	a_ctrl->step_position_table =
-		kmalloc(sizeof(uint16_t) *
-		(set_info->af_tuning_params.total_steps + 1), GFP_KERNEL);
+	curr_lens_pos = a_ctrl->step_position_table_manual[a_ctrl->curr_step_pos];
+	a_ctrl->i2c_tbl_index = 0;
+/*                                                                                       */
+#if 0// defined(CONFIG_MACH_APQ8064_AWIFI)
+	if(dest_step_pos <= 0)
+		dest_step_pos = 34;
+#endif
+/*                                                                                       */
 
-	if (a_ctrl->step_position_table == NULL)
-		return -EFAULT;
+	//                                                                                          
+	CDBG("curr_step_pos =%d dest_step_pos =%d curr_lens_pos=%d\n",
+		a_ctrl->curr_step_pos, dest_step_pos, curr_lens_pos);
+	//                                                                                        
 
-	cur_code = set_info->af_tuning_params.initial_code;
-	a_ctrl->step_position_table[step_index++] = cur_code;
-	for (region_index = 0;
-		region_index < a_ctrl->region_size;
-		region_index++) {
-		code_per_step =
-			a_ctrl->region_params[region_index].code_per_step;
+	while (a_ctrl->curr_step_pos != dest_step_pos) {
 		step_boundary =
-			a_ctrl->region_params[region_index].
-			step_bound[MOVE_NEAR];
-		for (; step_index <= step_boundary;
-			step_index++) {
-			cur_code += code_per_step;
-			if (cur_code < max_code_size)
-				a_ctrl->step_position_table[step_index] =
-					cur_code;
-			else {
-				for (; step_index <
-					set_info->af_tuning_params.total_steps;
-					step_index++)
-					a_ctrl->
-						step_position_table[
-						step_index] =
-						max_code_size;
+			a_ctrl->region_params[a_ctrl->curr_region_index].
+			step_bound[dir];
+		printk("test_step");
+		if ((dest_step_pos * sign_dir) <=
+			(step_boundary * sign_dir)) {
 
+/*                                                                                               */
+			struct damping_params_t damping_param, *usr_damping_param ; // namkyu2.kang
+/*                                                                                               */
+			target_step_pos = dest_step_pos;
+			target_lens_pos =
+				a_ctrl->step_position_table_manual[target_step_pos];
+/*                                                                                               */
+			usr_damping_param = &(move_params->ringing_params[a_ctrl->curr_region_index]) ;
+			if (copy_from_user(&damping_param,
+					(void *)usr_damping_param,
+					sizeof(struct damping_params_t)))
+			{
+				pr_err("%s: ringing_param is on FAULT Address : %p\n",
+						__func__, (void *)usr_damping_param ) ;
+				return -EFAULT;
+			}
+/*                                                                                               */
+			rc = a_ctrl->func_tbl->
+				actuator_write_focus(
+					a_ctrl,
+					curr_lens_pos,
+/*                                                                                               */
+//					&(move_params->
+//						ringing_params[a_ctrl->
+//						curr_region_index]),
+					&damping_param, // namkyu2.kang
+/*                                                                                               */
+					sign_dir,
+					target_lens_pos);
+			if (rc < 0) {
+				pr_err("%s: error:%d\n",
+					__func__, rc);
 				return rc;
 			}
+			curr_lens_pos = target_lens_pos;
+			//                                                                                             
+			count_actuator_write ++;
+			//printk("%s count_actuator_write = %d\n",__func__,count_actuator_write);
+			//                                                                                           
+
+		} else {
+/*                                                                                               */
+			struct damping_params_t damping_param, *usr_damping_param ; // namkyu2.kang
+/*                                                                                               */
+			target_step_pos = step_boundary;
+			target_lens_pos =
+				a_ctrl->step_position_table_manual[target_step_pos];
+/*                                                                                               */
+			usr_damping_param = &(move_params->ringing_params[a_ctrl->curr_region_index]) ;
+			if (copy_from_user(&damping_param,
+					(void *)usr_damping_param,
+					sizeof(struct damping_params_t)))
+			{
+				pr_err("%s: ringing_param is on FAULT Address : %p\n",
+						__func__, (void *)usr_damping_param ) ;
+				return -EFAULT;
+			}
+/*                                                                                               */
+			//pr_err("%s:[2] usr_damping_param = %p", __func__, usr_damping_param);
+			//pr_err("%s:[2] &(move_params->ringing_params[a_ctrl->curr_region_index]) = %p\n",  __func__, &(move_params->ringing_params[a_ctrl->curr_region_index]));
+			rc = a_ctrl->func_tbl->
+				actuator_write_focus(
+					a_ctrl,
+					curr_lens_pos,
+/*                                                                                               */
+//					&(move_params->
+//						ringing_params[a_ctrl->
+//						curr_region_index]),
+					&damping_param, // namkyu2.kang
+/*                                                                                               */
+					sign_dir,
+					target_lens_pos);
+			if (rc < 0) {
+				pr_err("%s: error:%d\n",
+					__func__, rc);
+				return rc;
+			}
+			curr_lens_pos = target_lens_pos;
+
+			a_ctrl->curr_region_index += sign_dir;
+			//                                                                                             
+			if (a_ctrl->curr_region_index >= 2)
+			{
+			 printk("[ERROR][%s] a_ctrl->curr_region_index = %d ---> 1\n",__func__,a_ctrl->curr_region_index);
+			 a_ctrl->curr_region_index = 1;
+			}
+			if (a_ctrl->curr_region_index < 0)
+			{
+			 printk("[ERROR][%s] a_ctrl->curr_region_index = %d ---> 0\n",__func__,a_ctrl->curr_region_index);
+			 a_ctrl->curr_region_index = 0;
+			}
+			count_actuator_write ++;
+			//printk("%s count_actuator_write = %d\n",__func__,count_actuator_write);
+			//                                                                                           
 		}
+		a_ctrl->curr_step_pos = target_step_pos;
+		//                                                                                             
+		if (count_actuator_write > 2)
+		{
+		   printk("[ERROR][%s] count_actuator_write = %d ---> break\n",__func__,count_actuator_write);
+		   break;
+	    }
+		//                                                                                           
+	}
+
+	rc = msm_camera_i2c_write_table_w_microdelay(&a_ctrl->i2c_client,
+		a_ctrl->i2c_reg_tbl, a_ctrl->i2c_tbl_index,
+		a_ctrl->i2c_data_type);
+	if (rc < 0) {
+		pr_err("%s: i2c write error:%d\n",
+			__func__, rc);
+		return rc;
 	}
+	a_ctrl->i2c_tbl_index = 0;
 
 	return rc;
 }
+#endif
+/*                                                                                               */
+
+//                                                                               
+static int32_t msm_actuator_init_step_table(struct msm_actuator_ctrl_t *a_ctrl,
+	struct msm_actuator_set_info_t *set_info);
+
+#if defined(CONFIG_IMX091)
+#define ACT_MIN_MOVE_RANGE	200 // TBD
+#define ACT_POSTURE_MARGIN   100 //                                                           
+
+extern uint8_t imx091_afcalib_data[8];
+/*                                                                 */
+extern uint8_t imx091_af_defocus_data[11];
+/*                                                                 */
+
+/*                                                                                     */
+#elif defined(CONFIG_S5K4E5YA_EEPROM) || defined(CONFIG_OV5693_EEPROM)
+#if defined(CONFIG_S5K4E5YA_EEPROM)
+extern uint8_t s5k4e5ya_afcalib_data[4];
+#endif
+#if defined(CONFIG_OV5693_EEPROM)
+extern uint8_t ov5693_afcalib_data[4];
+#endif
+/*                                                                                     */
+
+#define ACT_MIN_MOVE_RANGE	150 // TBD
+
+#if defined(CONFIG_MACH_APQ8064_AWIFI)
+#define ACT_POSTURE_MARGIN   (30) //                                                                            
+#define MANUAL_ACT_POSTURE_MARGIN   (-30) //                                                                                    
 
-#ifdef CONFIG_SEKONIX_LENS_ACT
-int32_t msm_actuator_init_step_table_use_eeprom(struct msm_actuator_ctrl_t *a_ctrl,
+#else
+#define ACT_POSTURE_MARGIN   (30) //                                                           
+#endif
+
+#define ACTUATOR_MIN_MOVE_RANGE 0
+#define ACTUATOR_MAX_MOVE_RANGE 1023
+#define ACTUATOR_MIN_INFINIT_RANGE 100	/*                                                                                                                        */
+#define ACTUATOR_MAX_INFINIT_RANGE 300	/*                                                                                                                        */
+#define ACTUATOR_MIN_MACRO_RANGE 370	/*                                                                                                                        */
+#define ACTUATOR_MAX_MACRO_RANGE 700	/*                                                                                                                        */
+#else
+#define ACT_MIN_MOVE_RANGE	200 // TBD
+#define ACT_POSTURE_MARGIN   100 //                                                           
+#endif // #if defined(CONFIG_IMX091)
+#if defined(CONFIG_IMX111)
+    extern uint8_t imx111_afcalib_data[4];
+#endif // #if defined(CONFIG_IMX111)
+static int32_t msm_actuator_init_step_table_use_eeprom(struct msm_actuator_ctrl_t *a_ctrl,
 	struct msm_actuator_set_info_t *set_info)
 {
 	int32_t rc = 0;
@@ -469,28 +718,107 @@
 	uint32_t max_code_size = 1;
 	uint16_t data_size = set_info->actuator_params.data_size;
 	uint16_t act_start = 0, act_macro = 0, move_range = 0;
-
-	CDBG("%s called\n", __func__);
-
-	if (set_info->af_tuning_params.total_steps < 1) {
-		pr_err("%s: total_steps is too small (%d)\n", __func__,
-				set_info->af_tuning_params.total_steps);
-		return -EINVAL;
-	}
-
+#if defined(CONFIG_MACH_APQ8064_AWIFI)
+	uint16_t move_range_manual = 0;
+#endif
 	for (; data_size > 0; data_size--)
 		max_code_size *= 2;
 
-	if (a_ctrl->step_position_table) {
-		kfree(a_ctrl->step_position_table);
-		a_ctrl->step_position_table = NULL;
-	}
+	kfree(a_ctrl->step_position_table);
+	a_ctrl->step_position_table = NULL;
+/*                                                                                               */
+#if defined(CONFIG_MACH_APQ8064_AWIFI)
+	kfree(a_ctrl->step_position_table_manual);
+	a_ctrl->step_position_table_manual= NULL;
+#endif
+/*                                                                                               */
 
+	CDBG("%s called\n", __func__);
+    //                                                                         
 	// set act_start, act_macro
+	#if defined(CONFIG_IMX091)
+	act_start = (uint16_t)(imx091_afcalib_data[1] << 8) |
+			imx091_afcalib_data[0];
+	act_macro = (uint16_t)(imx091_afcalib_data[3] << 8) |
+			imx091_afcalib_data[2];
+	printk("[QCTK_EEPROM][IMX091] %s: act_start = %d\n",__func__,act_start);
+	printk("[QCTK_EEPROM][IMX091] %s: act_macro = %d\n",__func__,act_macro);
+/*                                                                 */
+    printk("####  imx091_af_defocus_data 0 = %x ####\n",imx091_af_defocus_data[0]);
+    printk("####  imx091_af_defocus_data 1 = %x ####\n",imx091_af_defocus_data[1]);
+    printk("####  imx091_af_defocus_data 2 = %x ####\n",imx091_af_defocus_data[2]);
+    printk("####  imx091_af_defocus_data 3 = %x ####\n",imx091_af_defocus_data[3]);
+    printk("####  imx091_af_defocus_data 4 = %x ####\n",imx091_af_defocus_data[4]);
+    printk("####  imx091_af_defocus_data 5 = %x ####\n",imx091_af_defocus_data[5]);
+    printk("####  imx091_af_defocus_data 6 = %x ####\n",imx091_af_defocus_data[6]);
+
+
+    a_ctrl->AF_defocus_enable = (uint8_t) imx091_af_defocus_data[0];
+    a_ctrl->AF_center_best_code = (uint16_t) (imx091_af_defocus_data[1] << 8) |imx091_af_defocus_data[2];
+    a_ctrl->AF_balance_best_code = (uint16_t) (imx091_af_defocus_data[3] << 8) |imx091_af_defocus_data[4];
+    a_ctrl->AF_defocus_offset = (uint16_t) (imx091_af_defocus_data[5] << 8) |imx091_af_defocus_data[6];
+	a_ctrl->AF_LG_center_best_code = (uint16_t) (imx091_af_defocus_data[7] << 8) |imx091_af_defocus_data[8];
+    a_ctrl->AF_LG_defocus_offset = (uint16_t) (imx091_af_defocus_data[9] << 8) |imx091_af_defocus_data[10];
+
+    printk("####  AF_defocus_enable = %d ####\n",a_ctrl->AF_defocus_enable);
+    printk("####  AF_center_best_code = %d ####\n",a_ctrl->AF_center_best_code);
+    printk("####  AF_balance_best_code = %d ####\n",a_ctrl->AF_balance_best_code);
+    printk("####  AF_defocus_offset = %d ####\n",a_ctrl->AF_defocus_offset);
+	printk("####  AF_LG_center_best_code = %d ####\n",a_ctrl->AF_LG_center_best_code);
+    printk("####  AF_LG_defocus_offset = %d ####\n",a_ctrl->AF_LG_defocus_offset);
+/*                                                                 */
+
+/*                                                                                     */
+    #elif defined(CONFIG_S5K4E5YA_EEPROM) || defined(CONFIG_OV5693_EEPROM)
+        #if defined(CONFIG_S5K4E5YA_EEPROM)
+            if(act_start == 0 && act_macro == 0) { // to prevent value is not overwritten when 2 eeproms were configured at once.
+                act_start = (uint16_t)(s5k4e5ya_afcalib_data[1] << 8) |
+                s5k4e5ya_afcalib_data[0];
+                act_macro = (uint16_t)(s5k4e5ya_afcalib_data[3] << 8) |
+                s5k4e5ya_afcalib_data[2];
+                printk("[QCTK_EEPROM][s5k4e5ya] %s: act_start = %d\n",__func__,act_start);
+                printk("[QCTK_EEPROM][s5k4e5ya] %s: act_macro = %d\n",__func__,act_macro);
+            }
+        #endif
+        #if defined(CONFIG_OV5693_EEPROM)
+            if(act_start == 0 && act_macro == 0) { // to prevent value is not overwritten when 2 eeproms were configured at once.
+                act_start = (uint16_t)(ov5693_afcalib_data[1] << 8) |
+                ov5693_afcalib_data[0];
+                act_macro = (uint16_t)(ov5693_afcalib_data[3] << 8) |
+                ov5693_afcalib_data[2];
+                printk("[QCTK_EEPROM][ov5693] %s: act_start = %d\n",__func__,act_start);
+                printk("[QCTK_EEPROM][ov5693] %s: act_macro = %d\n",__func__,act_macro);
+            }
+        #endif
+/*                                                                                     */
+
+	if (act_start <= ACTUATOR_MIN_MOVE_RANGE || act_macro > ACTUATOR_MAX_MOVE_RANGE) {
+	    printk("[QTCK_EEPROM] Out of AF MIN-MAX Value, Not use eeprom\n");
+	    goto act_cal_fail;
+    }
+	if ((act_start < ACTUATOR_MIN_INFINIT_RANGE) || (act_start > ACTUATOR_MAX_INFINIT_RANGE)){
+		printk("[QTCK_EEPROM] Out of AF INFINIT calibration range, Not use eeprom\n");
+		goto act_cal_fail;
+	}
+	if ((act_macro < ACTUATOR_MIN_MACRO_RANGE) || (act_macro > ACTUATOR_MAX_MACRO_RANGE)){
+		printk("[QTCK_EEPROM] Out of AF MACRO calibration range, Not use eeprom\n");
+		goto act_cal_fail;
+	}
+	if (act_start >= act_macro){
+	    printk("[QTCK_EEPROM] Same as MIN and MAX Value, Not use eeprom\n");
+	    goto act_cal_fail;
+    }
+
+	#elif defined(CONFIG_IMX111)
 	act_start = (uint16_t)(imx111_afcalib_data[1] << 8) |
 			imx111_afcalib_data[0];
-	act_macro = ((uint16_t)(imx111_afcalib_data[3] << 8) |
-			imx111_afcalib_data[2])+20;
+	act_macro = (uint16_t)(imx111_afcalib_data[3] << 8) |
+			imx111_afcalib_data[2];
+	printk("[QCTK_EEPROM][IMX111] %s: act_start = %d\n",__func__,act_start);
+	printk("[QCTK_EEPROM][IMX111] %s: act_macro = %d\n",__func__,act_macro);
+	#endif
+	//                                                                       
+
 	/* Fill step position table */
 	a_ctrl->step_position_table =
 		kmalloc(sizeof(uint16_t) *
@@ -500,8 +828,21 @@
 		return -EFAULT;
 
 	cur_code = set_info->af_tuning_params.initial_code;
-	a_ctrl->step_position_table[step_index++] = cur_code;
+	a_ctrl->step_position_table[step_index] = cur_code;
 
+/*                                                                                               */
+#if defined(CONFIG_MACH_APQ8064_AWIFI)
+	a_ctrl->step_position_table_manual =
+		kmalloc(sizeof(uint16_t) *
+		(set_info->af_tuning_params.total_steps + 1), GFP_KERNEL);
+
+	if (a_ctrl->step_position_table_manual== NULL)
+		return -EFAULT;
+
+	cur_code = set_info->af_tuning_params.initial_code;
+	a_ctrl->step_position_table_manual[step_index] = cur_code;
+#endif
+/*                                                                                               */
 	// start code - by calibration data
 	if ( act_start > ACT_POSTURE_MARGIN )
 		a_ctrl->step_position_table[1] = act_start - ACT_POSTURE_MARGIN;
@@ -510,121 +851,97 @@
 
 	move_range = act_macro - a_ctrl->step_position_table[1];
 
+/*                                                                                               */
+#if defined(CONFIG_MACH_APQ8064_AWIFI)
+	if ( act_start > MANUAL_ACT_POSTURE_MARGIN )
+		a_ctrl->step_position_table_manual[1] = act_start - MANUAL_ACT_POSTURE_MARGIN;
+	else
+		a_ctrl->step_position_table_manual[1] = act_start ;
+
+	move_range_manual= act_macro - a_ctrl->step_position_table_manual[1];
+#endif
+/*                                                                                               */
+
+	printk("[QCTK_EEPROM] move_range: %d\n", move_range);
+	printk("[QCTK_EEPROM] a_ctrl->total_steps = %d\n",a_ctrl->total_steps);
+	printk("[QCTK_EEPROM] set_info->af_tuning_params.total_steps = %d\n",set_info->af_tuning_params.total_steps);
 
+    //                                                                                                 
 	if (move_range < ACT_MIN_MOVE_RANGE)
+	{
+	    printk("[QTCK_EEPROM] Not use eeprom\n");
+	    use_eeprom_make_table = 0;
 		goto act_cal_fail;
+	}
+	else
+	{
+	    printk("[QTCK_EEPROM] Use eeprom\n");
+		use_eeprom_make_table = 1;
+	}
+	//                                                                                               
 
 	for (step_index = 2;step_index < set_info->af_tuning_params.total_steps;step_index++) {
 		a_ctrl->step_position_table[step_index]
 			= ((step_index - 1) * move_range + ((set_info->af_tuning_params.total_steps - 1) >> 1))
 			/ (set_info->af_tuning_params.total_steps - 1) + a_ctrl->step_position_table[1];
+
+/*                                                                                               */
+#if defined(CONFIG_MACH_APQ8064_AWIFI)
+		a_ctrl->step_position_table_manual[step_index]
+			= ((step_index - 1) * move_range_manual+ ((set_info->af_tuning_params.total_steps - 1) >> 1))
+			/ (set_info->af_tuning_params.total_steps - 1) + a_ctrl->step_position_table_manual[1];
+#endif
+/*                                                                                               */
 	}
 
+/*                                                                   */
+	printk("Actuator Clibration table: start(%d),macro(%d) ==============\n",
+	act_start, act_macro);
+
 	for (step_index = 0; step_index < a_ctrl->total_steps; step_index++)
-		CDBG("step_position_table[%d]= %d\n",step_index,
+		printk("step_position_table[%d]= %d\n",step_index,
 		a_ctrl->step_position_table[step_index]);
+/*                                                                                               */
+#if defined(CONFIG_MACH_APQ8064_AWIFI)
+	for (step_index = 0; step_index < a_ctrl->total_steps; step_index++)
+		printk("step_position_table_manual[%d]= %d\n",step_index,
+		a_ctrl->step_position_table_manual[step_index]);
+#endif
+/*                                                                                               */
+/*                                                                   */
 	return rc;
 
 act_cal_fail:
 	pr_err("%s: calibration to default value not using eeprom data\n", __func__);
-	rc = msm_actuator_init_default_step_table(a_ctrl, set_info);
-	return rc;
-}
-
-#else
-/* add AF calibration parameters */
-int32_t msm_actuator_i2c_read_b_eeprom(struct msm_camera_i2c_client *dev_client,
-            unsigned char saddr, unsigned char *rxdata)
-{
-	int32_t rc = 0;
-	struct i2c_msg msgs[] = {
-		{
-			.addr  = saddr << 1,
-			.flags = 0,
-			.len   = 1,
-			.buf   = rxdata,
-		},
-		{
-			.addr  = saddr << 1,
-			.flags = I2C_M_RD,
-			.len   = 1,
-			.buf   = rxdata,
-		},
-	};
-
-	rc = i2c_transfer(dev_client->client->adapter, msgs, 2);
-	if (rc < 0)
-		CDBG("msm_actuator_i2c_read_b_eeprom failed 0x%x\n", saddr);
+	rc = msm_actuator_init_step_table(a_ctrl, set_info);
 	return rc;
 }
+//                                                                             
 
 static int32_t msm_actuator_init_step_table(struct msm_actuator_ctrl_t *a_ctrl,
-            struct msm_actuator_set_info_t *set_info)
+	struct msm_actuator_set_info_t *set_info)
 {
+	int16_t code_per_step = 0;
 	int32_t rc = 0;
 	int16_t cur_code = 0;
-	int16_t step_index = 0;
+	int16_t step_index = 0, region_index = 0;
+	uint16_t step_boundary = 0;
 	uint32_t max_code_size = 1;
 	uint16_t data_size = set_info->actuator_params.data_size;
-
-	uint16_t act_start = 0, act_macro = 0, move_range = 0;
-	unsigned char buf;
-
 	CDBG("%s called\n", __func__);
 
-	if (set_info->af_tuning_params.total_steps < 1) {
-		pr_err("%s: total_steps is too small (%d)\n", __func__,
-				set_info->af_tuning_params.total_steps);
-		return -EINVAL;
-	}
-
-	// read from eeprom
-	buf = ACTUATOR_START_ADDR;
-	rc = msm_actuator_i2c_read_b_eeprom(&a_ctrl->i2c_client,
-		ACTUATOR_EEPROM_SADDR, &buf);
-	if (rc < 0)
-		goto act_cal_fail;
-
-	act_start = (buf << 8) & 0xFF00;
-
-	buf = ACTUATOR_START_ADDR + 1;
-	rc = msm_actuator_i2c_read_b_eeprom(&a_ctrl->i2c_client,
-		ACTUATOR_EEPROM_SADDR, &buf);
-
-	if (rc < 0)
-		goto act_cal_fail;
-
-	act_start |= buf & 0xFF;
-	CDBG("%s: act_start = 0x%4x\n", __func__, act_start);
-
-	buf = ACTUATOR_MACRO_ADDR;
-	rc = msm_actuator_i2c_read_b_eeprom(&a_ctrl->i2c_client,
-		ACTUATOR_EEPROM_SADDR, &buf);
-
-	if (rc < 0)
-		goto act_cal_fail;
-
-	act_macro = (buf << 8) & 0xFF00;
-
-	buf = ACTUATOR_MACRO_ADDR + 1;
-	rc = msm_actuator_i2c_read_b_eeprom(&a_ctrl->i2c_client,
-		ACTUATOR_EEPROM_SADDR, &buf);
-
-	if (rc < 0)
-		goto act_cal_fail;
-
-	act_macro |= buf & 0xFF;
-	CDBG("%s: act_macro = 0x%4x\n", __func__, act_macro);
-
-
 	for (; data_size > 0; data_size--)
 		max_code_size *= 2;
 
-	if (a_ctrl->step_position_table) {
-		kfree(a_ctrl->step_position_table);
-		a_ctrl->step_position_table = NULL;
-	}
+	kfree(a_ctrl->step_position_table);
+	a_ctrl->step_position_table = NULL;
 
+	if (set_info->af_tuning_params.total_steps
+		>  MAX_ACTUATOR_AF_TOTAL_STEPS) {
+		pr_err("%s: Max actuator totalsteps exceeded = %d\n",
+		__func__, set_info->af_tuning_params.total_steps);
+		return -EFAULT;
+	}
 	/* Fill step position table */
 	a_ctrl->step_position_table =
 		kmalloc(sizeof(uint16_t) *
@@ -633,70 +950,118 @@
 	if (a_ctrl->step_position_table == NULL)
 		return -EFAULT;
 
-	//intial code
 	cur_code = set_info->af_tuning_params.initial_code;
-	a_ctrl->step_position_table[0] = a_ctrl->initial_code;
-
-	// start code - by calibration data
-	if (act_start > ACTUATOR_MARGIN)
-		a_ctrl->step_position_table[1] = act_start - ACTUATOR_MARGIN;
-	else
-		a_ctrl->step_position_table[1] = act_start;
-
-	move_range = act_macro - a_ctrl->step_position_table[1];
-	CDBG("%s: move_range = %d\n", __func__, move_range);
-
-	if (move_range < ACTUATOR_MIN_MOVE_RANGE)
-		goto act_cal_fail;
+	a_ctrl->step_position_table[step_index++] = cur_code;
+	for (region_index = 0;
+		region_index < a_ctrl->region_size;
+		region_index++) {
+		code_per_step =
+			a_ctrl->region_params[region_index].code_per_step;
+		step_boundary =
+			a_ctrl->region_params[region_index].
+			step_bound[MOVE_NEAR];
+		for (; step_index <= step_boundary;
+			step_index++) {
+			cur_code += code_per_step;
+			if (cur_code < max_code_size)
+				a_ctrl->step_position_table[step_index] =
+					cur_code;
+			else {
+				for (; step_index <
+					set_info->af_tuning_params.total_steps;
+					step_index++)
+					a_ctrl->
+						step_position_table[
+						step_index] =
+						max_code_size;
 
-	for (step_index = 2;step_index < set_info->af_tuning_params.total_steps;step_index++) {
-		a_ctrl->step_position_table[step_index]
-			= ((step_index - 1) * move_range + ((set_info->af_tuning_params.total_steps - 1) >> 1))
-			/ (set_info->af_tuning_params.total_steps - 1) + a_ctrl->step_position_table[1];
+				return rc;
+			}
+		}
 	}
+	//                                                                               
+	printk("[AF] Actuator Clibration table: not apply calibration data ==============\n");
+	for (step_index = 0; step_index < set_info->af_tuning_params.total_steps; step_index++)
+		printk("[AF] step_position_table[%d]= %d\n",step_index,
+		a_ctrl->step_position_table[step_index]);
+	//                                                                             
 
-	a_ctrl->curr_step_pos = 0;
-	a_ctrl->curr_region_index = 0;
-
-	return rc;
-
-act_cal_fail:
-	pr_err("%s:  act_cal_fail, call default_step_table\n", __func__);
-	rc = msm_actuator_init_default_step_table(a_ctrl, set_info);
 	return rc;
 }
 
-#endif
-
+#define IMX091_ACT_STOP_POS 10 // [G][Camera][Common] Fix the Actuator Noise - "Tick!" - Issue by adding delay in proportion to distance of "Infinite"
 static int32_t msm_actuator_set_default_focus(
 	struct msm_actuator_ctrl_t *a_ctrl,
 	struct msm_actuator_move_params_t *move_params)
 {
 	int32_t rc = 0;
+//  Start - [G][Camera][Common] youngwook.song Fix the Actuator Noise - "Tick!" - Issue by adding delay in proportion to distance of "Infinite"
+#if 1
+	uint32_t hw_damping;
+	unsigned int delay;
+	int init_pos, cur_dac, mid_dac, cur_pos;
 	CDBG("%s called\n", __func__);
 
-	if (a_ctrl->curr_step_pos != 0) {
-		rc = a_ctrl->func_tbl->actuator_move_focus(a_ctrl, move_params);
+	cur_pos = a_ctrl->curr_step_pos;
+	CDBG("%s: E\n", __func__);
+	if (a_ctrl->curr_step_pos != 0)
+	{
+		hw_damping = 0xA;
+		delay = 0;
+		init_pos = a_ctrl->initial_code;
+		cur_dac = a_ctrl->step_position_table[cur_pos];
+		mid_dac = a_ctrl->step_position_table[IMX091_ACT_STOP_POS];
+		CDBG("%s : init_pos : %d, cur_dac : %d, mid_dac : %d\n", __func__, init_pos, cur_dac, mid_dac);
+
+		if(cur_pos > IMX091_ACT_STOP_POS) {
+			// Start - [G][Camera][Common] seongjo.kim Fix kernel crash when exit camera
+			a_ctrl->func_tbl->actuator_parse_i2c_params(a_ctrl, mid_dac, hw_damping, 0);
+			rc = msm_camera_i2c_write_table_w_microdelay(&a_ctrl->i2c_client,
+			a_ctrl->i2c_reg_tbl, a_ctrl->i2c_tbl_index,
+			a_ctrl->i2c_data_type);
+			if (rc < 0) {
+				pr_err("%s: i2c write error:%d\n",
+					__func__, rc);
+				return rc;
+			}
+			a_ctrl->i2c_tbl_index = 0;
+			// End - [G][Camera][Common] seongjo.kim Fix kernel crash when exit camera
+			delay = (cur_dac - mid_dac) * 2 / 3;
+			if(delay > 300) delay = 300;
+			CDBG("%s: To mid - step = %d, position = %d, delay = %d", __func__, cur_pos, cur_dac, delay);
+			mdelay(delay);
+		} else
+			mid_dac = cur_dac;
+
+		hw_damping = 0x7;
+		delay = mid_dac / 2;
+		if(delay > 300) delay = 300;
+		// Start - [G][Camera][Common] seongjo.kim Fix kernel crash when exit camera
+		a_ctrl->func_tbl->actuator_parse_i2c_params(a_ctrl, init_pos + 10, hw_damping, 0);
+		rc = msm_camera_i2c_write_table_w_microdelay(&a_ctrl->i2c_client,
+		a_ctrl->i2c_reg_tbl, a_ctrl->i2c_tbl_index,
+		a_ctrl->i2c_data_type);
+		if (rc < 0) {
+			pr_err("%s: i2c write error:%d\n",
+				__func__, rc);
+			return rc;
+		}
+		a_ctrl->i2c_tbl_index = 0;
+		// End - [G][Camera][Common] seongjo.kim Fix kernel crash when exit camera
+		CDBG("%s: To end - step = 10, position = %d, delay = %d", __func__, mid_dac, delay);
+		mdelay(delay); 	// delay can be changed but put max due to it's small enough
+		a_ctrl->curr_step_pos = 0;
 	}
-
+#else // QCT Original Source.
+		rc = a_ctrl->func_tbl->actuator_move_focus(a_ctrl, move_params);
+#endif
+//* End - [G][Camera][Common] youngwook.song Fix the Actuator Noise - "Tick!" - Issue by adding delay in proportion to distance of "Infinite"
 	return rc;
 }
 
 static int32_t msm_actuator_power_down(struct msm_actuator_ctrl_t *a_ctrl)
 {
 	int32_t rc = 0;
-#ifdef CONFIG_SEKONIX_LENS_ACT
-	int cur_pos = a_ctrl->curr_step_pos;
-	struct msm_actuator_move_params_t move_params;
-
-	if(cur_pos > ACT_STOP_POS) {
-		move_params.sign_dir = MOVE_FAR;
-		move_params.dest_step_pos = ACT_STOP_POS;
-		rc = a_ctrl->func_tbl->actuator_move_focus(
-				a_ctrl, &move_params);
-		msleep(300);
-	}
-#endif
 	if (a_ctrl->vcm_enable) {
 		rc = gpio_direction_output(a_ctrl->vcm_pwd, 0);
 		if (!rc)
@@ -730,9 +1095,16 @@
 		pr_err("%s: Actuator function table not found\n", __func__);
 		return rc;
 	}
-
-	a_ctrl->region_size = set_info->af_tuning_params.region_size;
-	if (a_ctrl->region_size > MAX_ACTUATOR_REGION) {
+	if (set_info->af_tuning_params.total_steps
+		>  MAX_ACTUATOR_AF_TOTAL_STEPS) {
+		pr_err("%s: Max actuator totalsteps exceeded = %d\n",
+		__func__, set_info->af_tuning_params.total_steps);
+		return -EFAULT;
+	}
+	if (set_info->af_tuning_params.region_size <= MAX_ACTUATOR_REGION) {
+		a_ctrl->region_size = set_info->af_tuning_params.region_size;
+	} else {
+		a_ctrl->region_size = 0;
 		pr_err("%s: MAX_ACTUATOR_REGION is exceeded.\n", __func__);
 		return -EFAULT;
 	}
@@ -747,16 +1119,28 @@
 	a_ctrl->i2c_data_type = set_info->actuator_params.i2c_data_type;
 	a_ctrl->i2c_client.client->addr = set_info->actuator_params.i2c_addr;
 	a_ctrl->i2c_client.addr_type = set_info->actuator_params.i2c_addr_type;
-	a_ctrl->reg_tbl_size = set_info->actuator_params.reg_tbl_size;
-	if (a_ctrl->reg_tbl_size > MAX_ACTUATOR_REG_TBL_SIZE) {
+	if (set_info->actuator_params.reg_tbl_size <=
+		MAX_ACTUATOR_REG_TBL_SIZE) {
+		a_ctrl->reg_tbl_size = set_info->actuator_params.reg_tbl_size;
+	} else {
+		a_ctrl->reg_tbl_size = 0;
 		pr_err("%s: MAX_ACTUATOR_REG_TBL_SIZE is exceeded.\n",
 			__func__);
 		return -EFAULT;
 	}
 
-	a_ctrl->i2c_reg_tbl =
-		kmalloc(sizeof(struct msm_camera_i2c_reg_tbl) *
-		(set_info->af_tuning_params.total_steps + 1), GFP_KERNEL);
+	/*                                                                                                                                                   */
+#if 1
+		a_ctrl->i2c_reg_tbl =
+			kmalloc(sizeof(struct msm_camera_i2c_reg_tbl) *
+			((set_info->af_tuning_params.total_steps*2) + 1), GFP_KERNEL);
+#else
+		a_ctrl->i2c_reg_tbl =
+			kmalloc(sizeof(struct msm_camera_i2c_reg_tbl) *
+			(set_info->af_tuning_params.total_steps + 1), GFP_KERNEL);
+#endif
+	/*                                                                                                                                                   */
+
 	if (!a_ctrl->i2c_reg_tbl) {
 		pr_err("%s kmalloc fail\n", __func__);
 		return -EFAULT;
@@ -767,18 +1151,18 @@
 		a_ctrl->reg_tbl_size *
 		sizeof(struct msm_actuator_reg_params_t))) {
 		kfree(a_ctrl->i2c_reg_tbl);
-		a_ctrl->i2c_reg_tbl = NULL;
 		return -EFAULT;
 	}
 
-	if (set_info->actuator_params.init_setting_size) {
+	if (set_info->actuator_params.init_setting_size &&
+		set_info->actuator_params.init_setting_size
+		<= MAX_ACTUATOR_REG_TBL_SIZE) {
 		if (a_ctrl->func_tbl->actuator_init_focus) {
 			init_settings = kmalloc(sizeof(struct reg_settings_t) *
 				(set_info->actuator_params.init_setting_size),
 				GFP_KERNEL);
 			if (init_settings == NULL) {
 				kfree(a_ctrl->i2c_reg_tbl);
-				a_ctrl->i2c_reg_tbl = NULL;
 				pr_err("%s Error allocating memory for init_settings\n",
 					__func__);
 				return -EFAULT;
@@ -789,7 +1173,6 @@
 				sizeof(struct reg_settings_t))) {
 				kfree(init_settings);
 				kfree(a_ctrl->i2c_reg_tbl);
-				a_ctrl->i2c_reg_tbl = NULL;
 				pr_err("%s Error copying init_settings\n",
 					__func__);
 				return -EFAULT;
@@ -801,7 +1184,6 @@
 			kfree(init_settings);
 			if (rc < 0) {
 				kfree(a_ctrl->i2c_reg_tbl);
-				a_ctrl->i2c_reg_tbl = NULL;
 				pr_err("%s Error actuator_init_focus\n",
 					__func__);
 				return -EFAULT;
@@ -852,7 +1234,14 @@
 		if (rc < 0)
 			pr_err("%s move focus failed %d\n", __func__, rc);
 		break;
-
+/*                                                                                               */
+	case CFG_MOVE_FOCUS_MANUAL:
+		rc = a_ctrl->func_tbl->
+			actuator_move_focus_manual(a_ctrl, &cdata.cfg.move);
+		if (rc < 0)
+			pr_err("%s init manaul table failed %d\n", __func__, rc);
+		break;
+/*                                                                                               */
 	default:
 		break;
 	}
@@ -870,7 +1259,7 @@
 
 	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
 		pr_err("i2c_check_functionality failed\n");
-		rc = -ENODEV;
+		rc = -EFAULT;
 		goto probe_failure;
 	}
 
@@ -889,7 +1278,10 @@
 		act_ctrl_t->act_v4l2_subdev_ops);
 
 	CDBG("%s succeeded\n", __func__);
+	return rc;
+
 probe_failure:
+	pr_err("%s failed! rc = %d\n", __func__, rc);
 	return rc;
 }
 
@@ -976,6 +1368,7 @@
 static struct msm_actuator_ctrl_t msm_actuator_t = {
 	.i2c_driver = &msm_actuator_i2c_driver,
 	.act_v4l2_subdev_ops = &msm_actuator_subdev_ops,
+
 	.curr_step_pos = 0,
 	.curr_region_index = 0,
 	.actuator_mutex = &msm_actuator_mutex,
@@ -985,16 +1378,19 @@
 static struct msm_actuator msm_vcm_actuator_table = {
 	.act_type = ACTUATOR_VCM,
 	.func_tbl = {
-#ifdef CONFIG_SEKONIX_LENS_ACT
-	.actuator_init_step_table = msm_actuator_init_step_table_use_eeprom,
-#else
-	.actuator_init_step_table = msm_actuator_init_step_table,
+		//                                                                               
+		.actuator_init_step_table = msm_actuator_init_step_table_use_eeprom,
+		//                                                                             
+		.actuator_move_focus = msm_actuator_move_focus,
+		.actuator_write_focus = msm_actuator_write_focus,
+		.actuator_set_default_focus = msm_actuator_set_default_focus,
+		.actuator_init_focus = msm_actuator_init_focus,
+		.actuator_parse_i2c_params = msm_actuator_parse_i2c_params,
+/*                                                                                               */
+#if defined(CONFIG_MACH_APQ8064_AWIFI)
+		.actuator_move_focus_manual = msm_actuator_move_focus_manual,
 #endif
-	.actuator_move_focus = msm_actuator_move_focus,
-	.actuator_write_focus = msm_actuator_write_focus,
-	.actuator_set_default_focus = msm_actuator_set_default_focus,
-	.actuator_init_focus = msm_actuator_init_focus,
-	.actuator_parse_i2c_params = msm_actuator_parse_i2c_params,
+/*                                                                                               */
 	},
 };
 
